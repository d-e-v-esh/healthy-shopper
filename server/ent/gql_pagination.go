// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"healthyshopper/ent/address"
	"healthyshopper/ent/nutritionalinformation"
	"healthyshopper/ent/nutritionalinformationtable"
	"healthyshopper/ent/orderline"
	"healthyshopper/ent/orderstatus"
	"healthyshopper/ent/product"
	"healthyshopper/ent/productitem"
	"healthyshopper/ent/promotion"
	"healthyshopper/ent/shippingaddress"
	"healthyshopper/ent/shippingmethod"
	"healthyshopper/ent/shoporder"
	"healthyshopper/ent/shoppingcart"
	"healthyshopper/ent/shoppingcartitem"
	"healthyshopper/ent/user"
	"healthyshopper/ent/useraddress"
	"healthyshopper/ent/userreview"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AddressEdge is the edge representation of Address.
type AddressEdge struct {
	Node   *Address `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AddressConnection is the connection containing edges to Address.
type AddressConnection struct {
	Edges      []*AddressEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *AddressConnection) build(nodes []*Address, pager *addressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Address
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Address {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Address {
			return nodes[i]
		}
	}
	c.Edges = make([]*AddressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AddressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AddressPaginateOption enables pagination customization.
type AddressPaginateOption func(*addressPager) error

// WithAddressOrder configures pagination ordering.
func WithAddressOrder(order *AddressOrder) AddressPaginateOption {
	if order == nil {
		order = DefaultAddressOrder
	}
	o := *order
	return func(pager *addressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAddressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAddressFilter configures pagination filter.
func WithAddressFilter(filter func(*AddressQuery) (*AddressQuery, error)) AddressPaginateOption {
	return func(pager *addressPager) error {
		if filter == nil {
			return errors.New("AddressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type addressPager struct {
	reverse bool
	order   *AddressOrder
	filter  func(*AddressQuery) (*AddressQuery, error)
}

func newAddressPager(opts []AddressPaginateOption, reverse bool) (*addressPager, error) {
	pager := &addressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAddressOrder
	}
	return pager, nil
}

func (p *addressPager) applyFilter(query *AddressQuery) (*AddressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *addressPager) toCursor(a *Address) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *addressPager) applyCursors(query *AddressQuery, after, before *Cursor) (*AddressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAddressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *addressPager) applyOrder(query *AddressQuery) *AddressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAddressOrder.Field {
		query = query.Order(DefaultAddressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *addressPager) orderExpr(query *AddressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAddressOrder.Field {
			b.Comma().Ident(DefaultAddressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Address.
func (a *AddressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AddressPaginateOption,
) (*AddressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAddressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AddressConnection{Edges: []*AddressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AddressOrderField defines the ordering field of Address.
type AddressOrderField struct {
	// Value extracts the ordering value from the given Address.
	Value    func(*Address) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) address.OrderOption
	toCursor func(*Address) Cursor
}

// AddressOrder defines the ordering of Address.
type AddressOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AddressOrderField `json:"field"`
}

// DefaultAddressOrder is the default ordering of Address.
var DefaultAddressOrder = &AddressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AddressOrderField{
		Value: func(a *Address) (ent.Value, error) {
			return a.ID, nil
		},
		column: address.FieldID,
		toTerm: address.ByID,
		toCursor: func(a *Address) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Address into AddressEdge.
func (a *Address) ToEdge(order *AddressOrder) *AddressEdge {
	if order == nil {
		order = DefaultAddressOrder
	}
	return &AddressEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// NutritionalInformationEdge is the edge representation of NutritionalInformation.
type NutritionalInformationEdge struct {
	Node   *NutritionalInformation `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// NutritionalInformationConnection is the connection containing edges to NutritionalInformation.
type NutritionalInformationConnection struct {
	Edges      []*NutritionalInformationEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *NutritionalInformationConnection) build(nodes []*NutritionalInformation, pager *nutritionalinformationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *NutritionalInformation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NutritionalInformation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NutritionalInformation {
			return nodes[i]
		}
	}
	c.Edges = make([]*NutritionalInformationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NutritionalInformationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NutritionalInformationPaginateOption enables pagination customization.
type NutritionalInformationPaginateOption func(*nutritionalinformationPager) error

// WithNutritionalInformationOrder configures pagination ordering.
func WithNutritionalInformationOrder(order *NutritionalInformationOrder) NutritionalInformationPaginateOption {
	if order == nil {
		order = DefaultNutritionalInformationOrder
	}
	o := *order
	return func(pager *nutritionalinformationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNutritionalInformationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNutritionalInformationFilter configures pagination filter.
func WithNutritionalInformationFilter(filter func(*NutritionalInformationQuery) (*NutritionalInformationQuery, error)) NutritionalInformationPaginateOption {
	return func(pager *nutritionalinformationPager) error {
		if filter == nil {
			return errors.New("NutritionalInformationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type nutritionalinformationPager struct {
	reverse bool
	order   *NutritionalInformationOrder
	filter  func(*NutritionalInformationQuery) (*NutritionalInformationQuery, error)
}

func newNutritionalInformationPager(opts []NutritionalInformationPaginateOption, reverse bool) (*nutritionalinformationPager, error) {
	pager := &nutritionalinformationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNutritionalInformationOrder
	}
	return pager, nil
}

func (p *nutritionalinformationPager) applyFilter(query *NutritionalInformationQuery) (*NutritionalInformationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *nutritionalinformationPager) toCursor(ni *NutritionalInformation) Cursor {
	return p.order.Field.toCursor(ni)
}

func (p *nutritionalinformationPager) applyCursors(query *NutritionalInformationQuery, after, before *Cursor) (*NutritionalInformationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNutritionalInformationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *nutritionalinformationPager) applyOrder(query *NutritionalInformationQuery) *NutritionalInformationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNutritionalInformationOrder.Field {
		query = query.Order(DefaultNutritionalInformationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *nutritionalinformationPager) orderExpr(query *NutritionalInformationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNutritionalInformationOrder.Field {
			b.Comma().Ident(DefaultNutritionalInformationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NutritionalInformation.
func (ni *NutritionalInformationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NutritionalInformationPaginateOption,
) (*NutritionalInformationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNutritionalInformationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ni, err = pager.applyFilter(ni); err != nil {
		return nil, err
	}
	conn := &NutritionalInformationConnection{Edges: []*NutritionalInformationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ni.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ni, err = pager.applyCursors(ni, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ni.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ni.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ni = pager.applyOrder(ni)
	nodes, err := ni.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NutritionalInformationOrderField defines the ordering field of NutritionalInformation.
type NutritionalInformationOrderField struct {
	// Value extracts the ordering value from the given NutritionalInformation.
	Value    func(*NutritionalInformation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) nutritionalinformation.OrderOption
	toCursor func(*NutritionalInformation) Cursor
}

// NutritionalInformationOrder defines the ordering of NutritionalInformation.
type NutritionalInformationOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *NutritionalInformationOrderField `json:"field"`
}

// DefaultNutritionalInformationOrder is the default ordering of NutritionalInformation.
var DefaultNutritionalInformationOrder = &NutritionalInformationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NutritionalInformationOrderField{
		Value: func(ni *NutritionalInformation) (ent.Value, error) {
			return ni.ID, nil
		},
		column: nutritionalinformation.FieldID,
		toTerm: nutritionalinformation.ByID,
		toCursor: func(ni *NutritionalInformation) Cursor {
			return Cursor{ID: ni.ID}
		},
	},
}

// ToEdge converts NutritionalInformation into NutritionalInformationEdge.
func (ni *NutritionalInformation) ToEdge(order *NutritionalInformationOrder) *NutritionalInformationEdge {
	if order == nil {
		order = DefaultNutritionalInformationOrder
	}
	return &NutritionalInformationEdge{
		Node:   ni,
		Cursor: order.Field.toCursor(ni),
	}
}

// NutritionalInformationTableEdge is the edge representation of NutritionalInformationTable.
type NutritionalInformationTableEdge struct {
	Node   *NutritionalInformationTable `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// NutritionalInformationTableConnection is the connection containing edges to NutritionalInformationTable.
type NutritionalInformationTableConnection struct {
	Edges      []*NutritionalInformationTableEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *NutritionalInformationTableConnection) build(nodes []*NutritionalInformationTable, pager *nutritionalinformationtablePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *NutritionalInformationTable
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NutritionalInformationTable {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NutritionalInformationTable {
			return nodes[i]
		}
	}
	c.Edges = make([]*NutritionalInformationTableEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NutritionalInformationTableEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NutritionalInformationTablePaginateOption enables pagination customization.
type NutritionalInformationTablePaginateOption func(*nutritionalinformationtablePager) error

// WithNutritionalInformationTableOrder configures pagination ordering.
func WithNutritionalInformationTableOrder(order *NutritionalInformationTableOrder) NutritionalInformationTablePaginateOption {
	if order == nil {
		order = DefaultNutritionalInformationTableOrder
	}
	o := *order
	return func(pager *nutritionalinformationtablePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNutritionalInformationTableOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNutritionalInformationTableFilter configures pagination filter.
func WithNutritionalInformationTableFilter(filter func(*NutritionalInformationTableQuery) (*NutritionalInformationTableQuery, error)) NutritionalInformationTablePaginateOption {
	return func(pager *nutritionalinformationtablePager) error {
		if filter == nil {
			return errors.New("NutritionalInformationTableQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type nutritionalinformationtablePager struct {
	reverse bool
	order   *NutritionalInformationTableOrder
	filter  func(*NutritionalInformationTableQuery) (*NutritionalInformationTableQuery, error)
}

func newNutritionalInformationTablePager(opts []NutritionalInformationTablePaginateOption, reverse bool) (*nutritionalinformationtablePager, error) {
	pager := &nutritionalinformationtablePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNutritionalInformationTableOrder
	}
	return pager, nil
}

func (p *nutritionalinformationtablePager) applyFilter(query *NutritionalInformationTableQuery) (*NutritionalInformationTableQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *nutritionalinformationtablePager) toCursor(nit *NutritionalInformationTable) Cursor {
	return p.order.Field.toCursor(nit)
}

func (p *nutritionalinformationtablePager) applyCursors(query *NutritionalInformationTableQuery, after, before *Cursor) (*NutritionalInformationTableQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNutritionalInformationTableOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *nutritionalinformationtablePager) applyOrder(query *NutritionalInformationTableQuery) *NutritionalInformationTableQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNutritionalInformationTableOrder.Field {
		query = query.Order(DefaultNutritionalInformationTableOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *nutritionalinformationtablePager) orderExpr(query *NutritionalInformationTableQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNutritionalInformationTableOrder.Field {
			b.Comma().Ident(DefaultNutritionalInformationTableOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NutritionalInformationTable.
func (nit *NutritionalInformationTableQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NutritionalInformationTablePaginateOption,
) (*NutritionalInformationTableConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNutritionalInformationTablePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if nit, err = pager.applyFilter(nit); err != nil {
		return nil, err
	}
	conn := &NutritionalInformationTableConnection{Edges: []*NutritionalInformationTableEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := nit.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if nit, err = pager.applyCursors(nit, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		nit.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := nit.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	nit = pager.applyOrder(nit)
	nodes, err := nit.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NutritionalInformationTableOrderField defines the ordering field of NutritionalInformationTable.
type NutritionalInformationTableOrderField struct {
	// Value extracts the ordering value from the given NutritionalInformationTable.
	Value    func(*NutritionalInformationTable) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) nutritionalinformationtable.OrderOption
	toCursor func(*NutritionalInformationTable) Cursor
}

// NutritionalInformationTableOrder defines the ordering of NutritionalInformationTable.
type NutritionalInformationTableOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *NutritionalInformationTableOrderField `json:"field"`
}

// DefaultNutritionalInformationTableOrder is the default ordering of NutritionalInformationTable.
var DefaultNutritionalInformationTableOrder = &NutritionalInformationTableOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NutritionalInformationTableOrderField{
		Value: func(nit *NutritionalInformationTable) (ent.Value, error) {
			return nit.ID, nil
		},
		column: nutritionalinformationtable.FieldID,
		toTerm: nutritionalinformationtable.ByID,
		toCursor: func(nit *NutritionalInformationTable) Cursor {
			return Cursor{ID: nit.ID}
		},
	},
}

// ToEdge converts NutritionalInformationTable into NutritionalInformationTableEdge.
func (nit *NutritionalInformationTable) ToEdge(order *NutritionalInformationTableOrder) *NutritionalInformationTableEdge {
	if order == nil {
		order = DefaultNutritionalInformationTableOrder
	}
	return &NutritionalInformationTableEdge{
		Node:   nit,
		Cursor: order.Field.toCursor(nit),
	}
}

// OrderLineEdge is the edge representation of OrderLine.
type OrderLineEdge struct {
	Node   *OrderLine `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// OrderLineConnection is the connection containing edges to OrderLine.
type OrderLineConnection struct {
	Edges      []*OrderLineEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *OrderLineConnection) build(nodes []*OrderLine, pager *orderlinePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrderLine
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrderLine {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrderLine {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrderLineEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrderLineEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrderLinePaginateOption enables pagination customization.
type OrderLinePaginateOption func(*orderlinePager) error

// WithOrderLineOrder configures pagination ordering.
func WithOrderLineOrder(order *OrderLineOrder) OrderLinePaginateOption {
	if order == nil {
		order = DefaultOrderLineOrder
	}
	o := *order
	return func(pager *orderlinePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrderLineOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrderLineFilter configures pagination filter.
func WithOrderLineFilter(filter func(*OrderLineQuery) (*OrderLineQuery, error)) OrderLinePaginateOption {
	return func(pager *orderlinePager) error {
		if filter == nil {
			return errors.New("OrderLineQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orderlinePager struct {
	reverse bool
	order   *OrderLineOrder
	filter  func(*OrderLineQuery) (*OrderLineQuery, error)
}

func newOrderLinePager(opts []OrderLinePaginateOption, reverse bool) (*orderlinePager, error) {
	pager := &orderlinePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrderLineOrder
	}
	return pager, nil
}

func (p *orderlinePager) applyFilter(query *OrderLineQuery) (*OrderLineQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orderlinePager) toCursor(ol *OrderLine) Cursor {
	return p.order.Field.toCursor(ol)
}

func (p *orderlinePager) applyCursors(query *OrderLineQuery, after, before *Cursor) (*OrderLineQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrderLineOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orderlinePager) applyOrder(query *OrderLineQuery) *OrderLineQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrderLineOrder.Field {
		query = query.Order(DefaultOrderLineOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orderlinePager) orderExpr(query *OrderLineQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrderLineOrder.Field {
			b.Comma().Ident(DefaultOrderLineOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrderLine.
func (ol *OrderLineQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrderLinePaginateOption,
) (*OrderLineConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrderLinePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ol, err = pager.applyFilter(ol); err != nil {
		return nil, err
	}
	conn := &OrderLineConnection{Edges: []*OrderLineEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ol.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ol, err = pager.applyCursors(ol, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ol.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ol.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ol = pager.applyOrder(ol)
	nodes, err := ol.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrderLineOrderField defines the ordering field of OrderLine.
type OrderLineOrderField struct {
	// Value extracts the ordering value from the given OrderLine.
	Value    func(*OrderLine) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orderline.OrderOption
	toCursor func(*OrderLine) Cursor
}

// OrderLineOrder defines the ordering of OrderLine.
type OrderLineOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *OrderLineOrderField `json:"field"`
}

// DefaultOrderLineOrder is the default ordering of OrderLine.
var DefaultOrderLineOrder = &OrderLineOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrderLineOrderField{
		Value: func(ol *OrderLine) (ent.Value, error) {
			return ol.ID, nil
		},
		column: orderline.FieldID,
		toTerm: orderline.ByID,
		toCursor: func(ol *OrderLine) Cursor {
			return Cursor{ID: ol.ID}
		},
	},
}

// ToEdge converts OrderLine into OrderLineEdge.
func (ol *OrderLine) ToEdge(order *OrderLineOrder) *OrderLineEdge {
	if order == nil {
		order = DefaultOrderLineOrder
	}
	return &OrderLineEdge{
		Node:   ol,
		Cursor: order.Field.toCursor(ol),
	}
}

// OrderStatusEdge is the edge representation of OrderStatus.
type OrderStatusEdge struct {
	Node   *OrderStatus `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// OrderStatusConnection is the connection containing edges to OrderStatus.
type OrderStatusConnection struct {
	Edges      []*OrderStatusEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *OrderStatusConnection) build(nodes []*OrderStatus, pager *orderstatusPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrderStatus
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrderStatus {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrderStatus {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrderStatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrderStatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrderStatusPaginateOption enables pagination customization.
type OrderStatusPaginateOption func(*orderstatusPager) error

// WithOrderStatusOrder configures pagination ordering.
func WithOrderStatusOrder(order *OrderStatusOrder) OrderStatusPaginateOption {
	if order == nil {
		order = DefaultOrderStatusOrder
	}
	o := *order
	return func(pager *orderstatusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrderStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrderStatusFilter configures pagination filter.
func WithOrderStatusFilter(filter func(*OrderStatusQuery) (*OrderStatusQuery, error)) OrderStatusPaginateOption {
	return func(pager *orderstatusPager) error {
		if filter == nil {
			return errors.New("OrderStatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orderstatusPager struct {
	reverse bool
	order   *OrderStatusOrder
	filter  func(*OrderStatusQuery) (*OrderStatusQuery, error)
}

func newOrderStatusPager(opts []OrderStatusPaginateOption, reverse bool) (*orderstatusPager, error) {
	pager := &orderstatusPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrderStatusOrder
	}
	return pager, nil
}

func (p *orderstatusPager) applyFilter(query *OrderStatusQuery) (*OrderStatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orderstatusPager) toCursor(os *OrderStatus) Cursor {
	return p.order.Field.toCursor(os)
}

func (p *orderstatusPager) applyCursors(query *OrderStatusQuery, after, before *Cursor) (*OrderStatusQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrderStatusOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orderstatusPager) applyOrder(query *OrderStatusQuery) *OrderStatusQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrderStatusOrder.Field {
		query = query.Order(DefaultOrderStatusOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orderstatusPager) orderExpr(query *OrderStatusQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrderStatusOrder.Field {
			b.Comma().Ident(DefaultOrderStatusOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrderStatus.
func (os *OrderStatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrderStatusPaginateOption,
) (*OrderStatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrderStatusPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if os, err = pager.applyFilter(os); err != nil {
		return nil, err
	}
	conn := &OrderStatusConnection{Edges: []*OrderStatusEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := os.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if os, err = pager.applyCursors(os, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		os.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := os.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	os = pager.applyOrder(os)
	nodes, err := os.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrderStatusOrderField defines the ordering field of OrderStatus.
type OrderStatusOrderField struct {
	// Value extracts the ordering value from the given OrderStatus.
	Value    func(*OrderStatus) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orderstatus.OrderOption
	toCursor func(*OrderStatus) Cursor
}

// OrderStatusOrder defines the ordering of OrderStatus.
type OrderStatusOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *OrderStatusOrderField `json:"field"`
}

// DefaultOrderStatusOrder is the default ordering of OrderStatus.
var DefaultOrderStatusOrder = &OrderStatusOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrderStatusOrderField{
		Value: func(os *OrderStatus) (ent.Value, error) {
			return os.ID, nil
		},
		column: orderstatus.FieldID,
		toTerm: orderstatus.ByID,
		toCursor: func(os *OrderStatus) Cursor {
			return Cursor{ID: os.ID}
		},
	},
}

// ToEdge converts OrderStatus into OrderStatusEdge.
func (os *OrderStatus) ToEdge(order *OrderStatusOrder) *OrderStatusEdge {
	if order == nil {
		order = DefaultOrderStatusOrder
	}
	return &OrderStatusEdge{
		Node:   os,
		Cursor: order.Field.toCursor(os),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   *ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProductItemEdge is the edge representation of ProductItem.
type ProductItemEdge struct {
	Node   *ProductItem `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ProductItemConnection is the connection containing edges to ProductItem.
type ProductItemConnection struct {
	Edges      []*ProductItemEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ProductItemConnection) build(nodes []*ProductItem, pager *productitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductItemPaginateOption enables pagination customization.
type ProductItemPaginateOption func(*productitemPager) error

// WithProductItemOrder configures pagination ordering.
func WithProductItemOrder(order *ProductItemOrder) ProductItemPaginateOption {
	if order == nil {
		order = DefaultProductItemOrder
	}
	o := *order
	return func(pager *productitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductItemFilter configures pagination filter.
func WithProductItemFilter(filter func(*ProductItemQuery) (*ProductItemQuery, error)) ProductItemPaginateOption {
	return func(pager *productitemPager) error {
		if filter == nil {
			return errors.New("ProductItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productitemPager struct {
	reverse bool
	order   *ProductItemOrder
	filter  func(*ProductItemQuery) (*ProductItemQuery, error)
}

func newProductItemPager(opts []ProductItemPaginateOption, reverse bool) (*productitemPager, error) {
	pager := &productitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductItemOrder
	}
	return pager, nil
}

func (p *productitemPager) applyFilter(query *ProductItemQuery) (*ProductItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productitemPager) toCursor(pi *ProductItem) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *productitemPager) applyCursors(query *ProductItemQuery, after, before *Cursor) (*ProductItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productitemPager) applyOrder(query *ProductItemQuery) *ProductItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductItemOrder.Field {
		query = query.Order(DefaultProductItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productitemPager) orderExpr(query *ProductItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductItemOrder.Field {
			b.Comma().Ident(DefaultProductItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductItem.
func (pi *ProductItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductItemPaginateOption,
) (*ProductItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}
	conn := &ProductItemConnection{Edges: []*ProductItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pi.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pi, err = pager.applyCursors(pi, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pi = pager.applyOrder(pi)
	nodes, err := pi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProductItemOrderField defines the ordering field of ProductItem.
type ProductItemOrderField struct {
	// Value extracts the ordering value from the given ProductItem.
	Value    func(*ProductItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productitem.OrderOption
	toCursor func(*ProductItem) Cursor
}

// ProductItemOrder defines the ordering of ProductItem.
type ProductItemOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ProductItemOrderField `json:"field"`
}

// DefaultProductItemOrder is the default ordering of ProductItem.
var DefaultProductItemOrder = &ProductItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductItemOrderField{
		Value: func(pi *ProductItem) (ent.Value, error) {
			return pi.ID, nil
		},
		column: productitem.FieldID,
		toTerm: productitem.ByID,
		toCursor: func(pi *ProductItem) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts ProductItem into ProductItemEdge.
func (pi *ProductItem) ToEdge(order *ProductItemOrder) *ProductItemEdge {
	if order == nil {
		order = DefaultProductItemOrder
	}
	return &ProductItemEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// PromotionEdge is the edge representation of Promotion.
type PromotionEdge struct {
	Node   *Promotion `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PromotionConnection is the connection containing edges to Promotion.
type PromotionConnection struct {
	Edges      []*PromotionEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PromotionConnection) build(nodes []*Promotion, pager *promotionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Promotion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Promotion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Promotion {
			return nodes[i]
		}
	}
	c.Edges = make([]*PromotionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PromotionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PromotionPaginateOption enables pagination customization.
type PromotionPaginateOption func(*promotionPager) error

// WithPromotionOrder configures pagination ordering.
func WithPromotionOrder(order *PromotionOrder) PromotionPaginateOption {
	if order == nil {
		order = DefaultPromotionOrder
	}
	o := *order
	return func(pager *promotionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPromotionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPromotionFilter configures pagination filter.
func WithPromotionFilter(filter func(*PromotionQuery) (*PromotionQuery, error)) PromotionPaginateOption {
	return func(pager *promotionPager) error {
		if filter == nil {
			return errors.New("PromotionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type promotionPager struct {
	reverse bool
	order   *PromotionOrder
	filter  func(*PromotionQuery) (*PromotionQuery, error)
}

func newPromotionPager(opts []PromotionPaginateOption, reverse bool) (*promotionPager, error) {
	pager := &promotionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPromotionOrder
	}
	return pager, nil
}

func (p *promotionPager) applyFilter(query *PromotionQuery) (*PromotionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *promotionPager) toCursor(pr *Promotion) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *promotionPager) applyCursors(query *PromotionQuery, after, before *Cursor) (*PromotionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPromotionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *promotionPager) applyOrder(query *PromotionQuery) *PromotionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPromotionOrder.Field {
		query = query.Order(DefaultPromotionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *promotionPager) orderExpr(query *PromotionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPromotionOrder.Field {
			b.Comma().Ident(DefaultPromotionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Promotion.
func (pr *PromotionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PromotionPaginateOption,
) (*PromotionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPromotionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &PromotionConnection{Edges: []*PromotionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PromotionOrderField defines the ordering field of Promotion.
type PromotionOrderField struct {
	// Value extracts the ordering value from the given Promotion.
	Value    func(*Promotion) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) promotion.OrderOption
	toCursor func(*Promotion) Cursor
}

// PromotionOrder defines the ordering of Promotion.
type PromotionOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PromotionOrderField `json:"field"`
}

// DefaultPromotionOrder is the default ordering of Promotion.
var DefaultPromotionOrder = &PromotionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PromotionOrderField{
		Value: func(pr *Promotion) (ent.Value, error) {
			return pr.ID, nil
		},
		column: promotion.FieldID,
		toTerm: promotion.ByID,
		toCursor: func(pr *Promotion) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Promotion into PromotionEdge.
func (pr *Promotion) ToEdge(order *PromotionOrder) *PromotionEdge {
	if order == nil {
		order = DefaultPromotionOrder
	}
	return &PromotionEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ShippingAddressEdge is the edge representation of ShippingAddress.
type ShippingAddressEdge struct {
	Node   *ShippingAddress `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ShippingAddressConnection is the connection containing edges to ShippingAddress.
type ShippingAddressConnection struct {
	Edges      []*ShippingAddressEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ShippingAddressConnection) build(nodes []*ShippingAddress, pager *shippingaddressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShippingAddress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShippingAddress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShippingAddress {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShippingAddressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShippingAddressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShippingAddressPaginateOption enables pagination customization.
type ShippingAddressPaginateOption func(*shippingaddressPager) error

// WithShippingAddressOrder configures pagination ordering.
func WithShippingAddressOrder(order *ShippingAddressOrder) ShippingAddressPaginateOption {
	if order == nil {
		order = DefaultShippingAddressOrder
	}
	o := *order
	return func(pager *shippingaddressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShippingAddressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShippingAddressFilter configures pagination filter.
func WithShippingAddressFilter(filter func(*ShippingAddressQuery) (*ShippingAddressQuery, error)) ShippingAddressPaginateOption {
	return func(pager *shippingaddressPager) error {
		if filter == nil {
			return errors.New("ShippingAddressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shippingaddressPager struct {
	reverse bool
	order   *ShippingAddressOrder
	filter  func(*ShippingAddressQuery) (*ShippingAddressQuery, error)
}

func newShippingAddressPager(opts []ShippingAddressPaginateOption, reverse bool) (*shippingaddressPager, error) {
	pager := &shippingaddressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShippingAddressOrder
	}
	return pager, nil
}

func (p *shippingaddressPager) applyFilter(query *ShippingAddressQuery) (*ShippingAddressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shippingaddressPager) toCursor(sa *ShippingAddress) Cursor {
	return p.order.Field.toCursor(sa)
}

func (p *shippingaddressPager) applyCursors(query *ShippingAddressQuery, after, before *Cursor) (*ShippingAddressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShippingAddressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shippingaddressPager) applyOrder(query *ShippingAddressQuery) *ShippingAddressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShippingAddressOrder.Field {
		query = query.Order(DefaultShippingAddressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shippingaddressPager) orderExpr(query *ShippingAddressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShippingAddressOrder.Field {
			b.Comma().Ident(DefaultShippingAddressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShippingAddress.
func (sa *ShippingAddressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShippingAddressPaginateOption,
) (*ShippingAddressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShippingAddressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sa, err = pager.applyFilter(sa); err != nil {
		return nil, err
	}
	conn := &ShippingAddressConnection{Edges: []*ShippingAddressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sa, err = pager.applyCursors(sa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sa = pager.applyOrder(sa)
	nodes, err := sa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShippingAddressOrderField defines the ordering field of ShippingAddress.
type ShippingAddressOrderField struct {
	// Value extracts the ordering value from the given ShippingAddress.
	Value    func(*ShippingAddress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shippingaddress.OrderOption
	toCursor func(*ShippingAddress) Cursor
}

// ShippingAddressOrder defines the ordering of ShippingAddress.
type ShippingAddressOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ShippingAddressOrderField `json:"field"`
}

// DefaultShippingAddressOrder is the default ordering of ShippingAddress.
var DefaultShippingAddressOrder = &ShippingAddressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.ID, nil
		},
		column: shippingaddress.FieldID,
		toTerm: shippingaddress.ByID,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{ID: sa.ID}
		},
	},
}

// ToEdge converts ShippingAddress into ShippingAddressEdge.
func (sa *ShippingAddress) ToEdge(order *ShippingAddressOrder) *ShippingAddressEdge {
	if order == nil {
		order = DefaultShippingAddressOrder
	}
	return &ShippingAddressEdge{
		Node:   sa,
		Cursor: order.Field.toCursor(sa),
	}
}

// ShippingMethodEdge is the edge representation of ShippingMethod.
type ShippingMethodEdge struct {
	Node   *ShippingMethod `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ShippingMethodConnection is the connection containing edges to ShippingMethod.
type ShippingMethodConnection struct {
	Edges      []*ShippingMethodEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ShippingMethodConnection) build(nodes []*ShippingMethod, pager *shippingmethodPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShippingMethod
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShippingMethod {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShippingMethod {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShippingMethodEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShippingMethodEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShippingMethodPaginateOption enables pagination customization.
type ShippingMethodPaginateOption func(*shippingmethodPager) error

// WithShippingMethodOrder configures pagination ordering.
func WithShippingMethodOrder(order *ShippingMethodOrder) ShippingMethodPaginateOption {
	if order == nil {
		order = DefaultShippingMethodOrder
	}
	o := *order
	return func(pager *shippingmethodPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShippingMethodOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShippingMethodFilter configures pagination filter.
func WithShippingMethodFilter(filter func(*ShippingMethodQuery) (*ShippingMethodQuery, error)) ShippingMethodPaginateOption {
	return func(pager *shippingmethodPager) error {
		if filter == nil {
			return errors.New("ShippingMethodQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shippingmethodPager struct {
	reverse bool
	order   *ShippingMethodOrder
	filter  func(*ShippingMethodQuery) (*ShippingMethodQuery, error)
}

func newShippingMethodPager(opts []ShippingMethodPaginateOption, reverse bool) (*shippingmethodPager, error) {
	pager := &shippingmethodPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShippingMethodOrder
	}
	return pager, nil
}

func (p *shippingmethodPager) applyFilter(query *ShippingMethodQuery) (*ShippingMethodQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shippingmethodPager) toCursor(sm *ShippingMethod) Cursor {
	return p.order.Field.toCursor(sm)
}

func (p *shippingmethodPager) applyCursors(query *ShippingMethodQuery, after, before *Cursor) (*ShippingMethodQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShippingMethodOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shippingmethodPager) applyOrder(query *ShippingMethodQuery) *ShippingMethodQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShippingMethodOrder.Field {
		query = query.Order(DefaultShippingMethodOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shippingmethodPager) orderExpr(query *ShippingMethodQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShippingMethodOrder.Field {
			b.Comma().Ident(DefaultShippingMethodOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShippingMethod.
func (sm *ShippingMethodQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShippingMethodPaginateOption,
) (*ShippingMethodConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShippingMethodPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sm, err = pager.applyFilter(sm); err != nil {
		return nil, err
	}
	conn := &ShippingMethodConnection{Edges: []*ShippingMethodEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sm.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sm, err = pager.applyCursors(sm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sm = pager.applyOrder(sm)
	nodes, err := sm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShippingMethodOrderField defines the ordering field of ShippingMethod.
type ShippingMethodOrderField struct {
	// Value extracts the ordering value from the given ShippingMethod.
	Value    func(*ShippingMethod) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shippingmethod.OrderOption
	toCursor func(*ShippingMethod) Cursor
}

// ShippingMethodOrder defines the ordering of ShippingMethod.
type ShippingMethodOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ShippingMethodOrderField `json:"field"`
}

// DefaultShippingMethodOrder is the default ordering of ShippingMethod.
var DefaultShippingMethodOrder = &ShippingMethodOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShippingMethodOrderField{
		Value: func(sm *ShippingMethod) (ent.Value, error) {
			return sm.ID, nil
		},
		column: shippingmethod.FieldID,
		toTerm: shippingmethod.ByID,
		toCursor: func(sm *ShippingMethod) Cursor {
			return Cursor{ID: sm.ID}
		},
	},
}

// ToEdge converts ShippingMethod into ShippingMethodEdge.
func (sm *ShippingMethod) ToEdge(order *ShippingMethodOrder) *ShippingMethodEdge {
	if order == nil {
		order = DefaultShippingMethodOrder
	}
	return &ShippingMethodEdge{
		Node:   sm,
		Cursor: order.Field.toCursor(sm),
	}
}

// ShopOrderEdge is the edge representation of ShopOrder.
type ShopOrderEdge struct {
	Node   *ShopOrder `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ShopOrderConnection is the connection containing edges to ShopOrder.
type ShopOrderConnection struct {
	Edges      []*ShopOrderEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ShopOrderConnection) build(nodes []*ShopOrder, pager *shoporderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShopOrder
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShopOrder {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShopOrder {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShopOrderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShopOrderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShopOrderPaginateOption enables pagination customization.
type ShopOrderPaginateOption func(*shoporderPager) error

// WithShopOrderOrder configures pagination ordering.
func WithShopOrderOrder(order *ShopOrderOrder) ShopOrderPaginateOption {
	if order == nil {
		order = DefaultShopOrderOrder
	}
	o := *order
	return func(pager *shoporderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShopOrderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShopOrderFilter configures pagination filter.
func WithShopOrderFilter(filter func(*ShopOrderQuery) (*ShopOrderQuery, error)) ShopOrderPaginateOption {
	return func(pager *shoporderPager) error {
		if filter == nil {
			return errors.New("ShopOrderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shoporderPager struct {
	reverse bool
	order   *ShopOrderOrder
	filter  func(*ShopOrderQuery) (*ShopOrderQuery, error)
}

func newShopOrderPager(opts []ShopOrderPaginateOption, reverse bool) (*shoporderPager, error) {
	pager := &shoporderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShopOrderOrder
	}
	return pager, nil
}

func (p *shoporderPager) applyFilter(query *ShopOrderQuery) (*ShopOrderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shoporderPager) toCursor(so *ShopOrder) Cursor {
	return p.order.Field.toCursor(so)
}

func (p *shoporderPager) applyCursors(query *ShopOrderQuery, after, before *Cursor) (*ShopOrderQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShopOrderOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shoporderPager) applyOrder(query *ShopOrderQuery) *ShopOrderQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShopOrderOrder.Field {
		query = query.Order(DefaultShopOrderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shoporderPager) orderExpr(query *ShopOrderQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShopOrderOrder.Field {
			b.Comma().Ident(DefaultShopOrderOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShopOrder.
func (so *ShopOrderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShopOrderPaginateOption,
) (*ShopOrderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShopOrderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if so, err = pager.applyFilter(so); err != nil {
		return nil, err
	}
	conn := &ShopOrderConnection{Edges: []*ShopOrderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := so.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if so, err = pager.applyCursors(so, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		so.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := so.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	so = pager.applyOrder(so)
	nodes, err := so.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShopOrderOrderField defines the ordering field of ShopOrder.
type ShopOrderOrderField struct {
	// Value extracts the ordering value from the given ShopOrder.
	Value    func(*ShopOrder) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shoporder.OrderOption
	toCursor func(*ShopOrder) Cursor
}

// ShopOrderOrder defines the ordering of ShopOrder.
type ShopOrderOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ShopOrderOrderField `json:"field"`
}

// DefaultShopOrderOrder is the default ordering of ShopOrder.
var DefaultShopOrderOrder = &ShopOrderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShopOrderOrderField{
		Value: func(so *ShopOrder) (ent.Value, error) {
			return so.ID, nil
		},
		column: shoporder.FieldID,
		toTerm: shoporder.ByID,
		toCursor: func(so *ShopOrder) Cursor {
			return Cursor{ID: so.ID}
		},
	},
}

// ToEdge converts ShopOrder into ShopOrderEdge.
func (so *ShopOrder) ToEdge(order *ShopOrderOrder) *ShopOrderEdge {
	if order == nil {
		order = DefaultShopOrderOrder
	}
	return &ShopOrderEdge{
		Node:   so,
		Cursor: order.Field.toCursor(so),
	}
}

// ShoppingCartEdge is the edge representation of ShoppingCart.
type ShoppingCartEdge struct {
	Node   *ShoppingCart `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ShoppingCartConnection is the connection containing edges to ShoppingCart.
type ShoppingCartConnection struct {
	Edges      []*ShoppingCartEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ShoppingCartConnection) build(nodes []*ShoppingCart, pager *shoppingcartPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShoppingCart
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShoppingCart {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShoppingCart {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShoppingCartEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShoppingCartEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShoppingCartPaginateOption enables pagination customization.
type ShoppingCartPaginateOption func(*shoppingcartPager) error

// WithShoppingCartOrder configures pagination ordering.
func WithShoppingCartOrder(order *ShoppingCartOrder) ShoppingCartPaginateOption {
	if order == nil {
		order = DefaultShoppingCartOrder
	}
	o := *order
	return func(pager *shoppingcartPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShoppingCartOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShoppingCartFilter configures pagination filter.
func WithShoppingCartFilter(filter func(*ShoppingCartQuery) (*ShoppingCartQuery, error)) ShoppingCartPaginateOption {
	return func(pager *shoppingcartPager) error {
		if filter == nil {
			return errors.New("ShoppingCartQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shoppingcartPager struct {
	reverse bool
	order   *ShoppingCartOrder
	filter  func(*ShoppingCartQuery) (*ShoppingCartQuery, error)
}

func newShoppingCartPager(opts []ShoppingCartPaginateOption, reverse bool) (*shoppingcartPager, error) {
	pager := &shoppingcartPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShoppingCartOrder
	}
	return pager, nil
}

func (p *shoppingcartPager) applyFilter(query *ShoppingCartQuery) (*ShoppingCartQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shoppingcartPager) toCursor(sc *ShoppingCart) Cursor {
	return p.order.Field.toCursor(sc)
}

func (p *shoppingcartPager) applyCursors(query *ShoppingCartQuery, after, before *Cursor) (*ShoppingCartQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShoppingCartOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shoppingcartPager) applyOrder(query *ShoppingCartQuery) *ShoppingCartQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShoppingCartOrder.Field {
		query = query.Order(DefaultShoppingCartOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shoppingcartPager) orderExpr(query *ShoppingCartQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShoppingCartOrder.Field {
			b.Comma().Ident(DefaultShoppingCartOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShoppingCart.
func (sc *ShoppingCartQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShoppingCartPaginateOption,
) (*ShoppingCartConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShoppingCartPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sc, err = pager.applyFilter(sc); err != nil {
		return nil, err
	}
	conn := &ShoppingCartConnection{Edges: []*ShoppingCartEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sc, err = pager.applyCursors(sc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sc = pager.applyOrder(sc)
	nodes, err := sc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShoppingCartOrderField defines the ordering field of ShoppingCart.
type ShoppingCartOrderField struct {
	// Value extracts the ordering value from the given ShoppingCart.
	Value    func(*ShoppingCart) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shoppingcart.OrderOption
	toCursor func(*ShoppingCart) Cursor
}

// ShoppingCartOrder defines the ordering of ShoppingCart.
type ShoppingCartOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ShoppingCartOrderField `json:"field"`
}

// DefaultShoppingCartOrder is the default ordering of ShoppingCart.
var DefaultShoppingCartOrder = &ShoppingCartOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShoppingCartOrderField{
		Value: func(sc *ShoppingCart) (ent.Value, error) {
			return sc.ID, nil
		},
		column: shoppingcart.FieldID,
		toTerm: shoppingcart.ByID,
		toCursor: func(sc *ShoppingCart) Cursor {
			return Cursor{ID: sc.ID}
		},
	},
}

// ToEdge converts ShoppingCart into ShoppingCartEdge.
func (sc *ShoppingCart) ToEdge(order *ShoppingCartOrder) *ShoppingCartEdge {
	if order == nil {
		order = DefaultShoppingCartOrder
	}
	return &ShoppingCartEdge{
		Node:   sc,
		Cursor: order.Field.toCursor(sc),
	}
}

// ShoppingCartItemEdge is the edge representation of ShoppingCartItem.
type ShoppingCartItemEdge struct {
	Node   *ShoppingCartItem `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ShoppingCartItemConnection is the connection containing edges to ShoppingCartItem.
type ShoppingCartItemConnection struct {
	Edges      []*ShoppingCartItemEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ShoppingCartItemConnection) build(nodes []*ShoppingCartItem, pager *shoppingcartitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShoppingCartItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShoppingCartItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShoppingCartItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShoppingCartItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShoppingCartItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShoppingCartItemPaginateOption enables pagination customization.
type ShoppingCartItemPaginateOption func(*shoppingcartitemPager) error

// WithShoppingCartItemOrder configures pagination ordering.
func WithShoppingCartItemOrder(order *ShoppingCartItemOrder) ShoppingCartItemPaginateOption {
	if order == nil {
		order = DefaultShoppingCartItemOrder
	}
	o := *order
	return func(pager *shoppingcartitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShoppingCartItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShoppingCartItemFilter configures pagination filter.
func WithShoppingCartItemFilter(filter func(*ShoppingCartItemQuery) (*ShoppingCartItemQuery, error)) ShoppingCartItemPaginateOption {
	return func(pager *shoppingcartitemPager) error {
		if filter == nil {
			return errors.New("ShoppingCartItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shoppingcartitemPager struct {
	reverse bool
	order   *ShoppingCartItemOrder
	filter  func(*ShoppingCartItemQuery) (*ShoppingCartItemQuery, error)
}

func newShoppingCartItemPager(opts []ShoppingCartItemPaginateOption, reverse bool) (*shoppingcartitemPager, error) {
	pager := &shoppingcartitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShoppingCartItemOrder
	}
	return pager, nil
}

func (p *shoppingcartitemPager) applyFilter(query *ShoppingCartItemQuery) (*ShoppingCartItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shoppingcartitemPager) toCursor(sci *ShoppingCartItem) Cursor {
	return p.order.Field.toCursor(sci)
}

func (p *shoppingcartitemPager) applyCursors(query *ShoppingCartItemQuery, after, before *Cursor) (*ShoppingCartItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShoppingCartItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shoppingcartitemPager) applyOrder(query *ShoppingCartItemQuery) *ShoppingCartItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShoppingCartItemOrder.Field {
		query = query.Order(DefaultShoppingCartItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shoppingcartitemPager) orderExpr(query *ShoppingCartItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShoppingCartItemOrder.Field {
			b.Comma().Ident(DefaultShoppingCartItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShoppingCartItem.
func (sci *ShoppingCartItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShoppingCartItemPaginateOption,
) (*ShoppingCartItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShoppingCartItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sci, err = pager.applyFilter(sci); err != nil {
		return nil, err
	}
	conn := &ShoppingCartItemConnection{Edges: []*ShoppingCartItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sci.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sci, err = pager.applyCursors(sci, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sci.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sci.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sci = pager.applyOrder(sci)
	nodes, err := sci.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShoppingCartItemOrderField defines the ordering field of ShoppingCartItem.
type ShoppingCartItemOrderField struct {
	// Value extracts the ordering value from the given ShoppingCartItem.
	Value    func(*ShoppingCartItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shoppingcartitem.OrderOption
	toCursor func(*ShoppingCartItem) Cursor
}

// ShoppingCartItemOrder defines the ordering of ShoppingCartItem.
type ShoppingCartItemOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ShoppingCartItemOrderField `json:"field"`
}

// DefaultShoppingCartItemOrder is the default ordering of ShoppingCartItem.
var DefaultShoppingCartItemOrder = &ShoppingCartItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShoppingCartItemOrderField{
		Value: func(sci *ShoppingCartItem) (ent.Value, error) {
			return sci.ID, nil
		},
		column: shoppingcartitem.FieldID,
		toTerm: shoppingcartitem.ByID,
		toCursor: func(sci *ShoppingCartItem) Cursor {
			return Cursor{ID: sci.ID}
		},
	},
}

// ToEdge converts ShoppingCartItem into ShoppingCartItemEdge.
func (sci *ShoppingCartItem) ToEdge(order *ShoppingCartItemOrder) *ShoppingCartItemEdge {
	if order == nil {
		order = DefaultShoppingCartItemOrder
	}
	return &ShoppingCartItemEdge{
		Node:   sci,
		Cursor: order.Field.toCursor(sci),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserAddressEdge is the edge representation of UserAddress.
type UserAddressEdge struct {
	Node   *UserAddress `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserAddressConnection is the connection containing edges to UserAddress.
type UserAddressConnection struct {
	Edges      []*UserAddressEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserAddressConnection) build(nodes []*UserAddress, pager *useraddressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserAddress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserAddress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserAddress {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserAddressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserAddressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserAddressPaginateOption enables pagination customization.
type UserAddressPaginateOption func(*useraddressPager) error

// WithUserAddressOrder configures pagination ordering.
func WithUserAddressOrder(order *UserAddressOrder) UserAddressPaginateOption {
	if order == nil {
		order = DefaultUserAddressOrder
	}
	o := *order
	return func(pager *useraddressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserAddressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserAddressFilter configures pagination filter.
func WithUserAddressFilter(filter func(*UserAddressQuery) (*UserAddressQuery, error)) UserAddressPaginateOption {
	return func(pager *useraddressPager) error {
		if filter == nil {
			return errors.New("UserAddressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type useraddressPager struct {
	reverse bool
	order   *UserAddressOrder
	filter  func(*UserAddressQuery) (*UserAddressQuery, error)
}

func newUserAddressPager(opts []UserAddressPaginateOption, reverse bool) (*useraddressPager, error) {
	pager := &useraddressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserAddressOrder
	}
	return pager, nil
}

func (p *useraddressPager) applyFilter(query *UserAddressQuery) (*UserAddressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *useraddressPager) toCursor(ua *UserAddress) Cursor {
	return p.order.Field.toCursor(ua)
}

func (p *useraddressPager) applyCursors(query *UserAddressQuery, after, before *Cursor) (*UserAddressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserAddressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *useraddressPager) applyOrder(query *UserAddressQuery) *UserAddressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserAddressOrder.Field {
		query = query.Order(DefaultUserAddressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *useraddressPager) orderExpr(query *UserAddressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserAddressOrder.Field {
			b.Comma().Ident(DefaultUserAddressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserAddress.
func (ua *UserAddressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserAddressPaginateOption,
) (*UserAddressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserAddressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ua, err = pager.applyFilter(ua); err != nil {
		return nil, err
	}
	conn := &UserAddressConnection{Edges: []*UserAddressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ua.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ua, err = pager.applyCursors(ua, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ua.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ua.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ua = pager.applyOrder(ua)
	nodes, err := ua.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserAddressOrderField defines the ordering field of UserAddress.
type UserAddressOrderField struct {
	// Value extracts the ordering value from the given UserAddress.
	Value    func(*UserAddress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) useraddress.OrderOption
	toCursor func(*UserAddress) Cursor
}

// UserAddressOrder defines the ordering of UserAddress.
type UserAddressOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserAddressOrderField `json:"field"`
}

// DefaultUserAddressOrder is the default ordering of UserAddress.
var DefaultUserAddressOrder = &UserAddressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserAddressOrderField{
		Value: func(ua *UserAddress) (ent.Value, error) {
			return ua.ID, nil
		},
		column: useraddress.FieldID,
		toTerm: useraddress.ByID,
		toCursor: func(ua *UserAddress) Cursor {
			return Cursor{ID: ua.ID}
		},
	},
}

// ToEdge converts UserAddress into UserAddressEdge.
func (ua *UserAddress) ToEdge(order *UserAddressOrder) *UserAddressEdge {
	if order == nil {
		order = DefaultUserAddressOrder
	}
	return &UserAddressEdge{
		Node:   ua,
		Cursor: order.Field.toCursor(ua),
	}
}

// UserReviewEdge is the edge representation of UserReview.
type UserReviewEdge struct {
	Node   *UserReview `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// UserReviewConnection is the connection containing edges to UserReview.
type UserReviewConnection struct {
	Edges      []*UserReviewEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *UserReviewConnection) build(nodes []*UserReview, pager *userreviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserReview
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserReview {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserReview {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserReviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserReviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserReviewPaginateOption enables pagination customization.
type UserReviewPaginateOption func(*userreviewPager) error

// WithUserReviewOrder configures pagination ordering.
func WithUserReviewOrder(order *UserReviewOrder) UserReviewPaginateOption {
	if order == nil {
		order = DefaultUserReviewOrder
	}
	o := *order
	return func(pager *userreviewPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserReviewOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserReviewFilter configures pagination filter.
func WithUserReviewFilter(filter func(*UserReviewQuery) (*UserReviewQuery, error)) UserReviewPaginateOption {
	return func(pager *userreviewPager) error {
		if filter == nil {
			return errors.New("UserReviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userreviewPager struct {
	reverse bool
	order   *UserReviewOrder
	filter  func(*UserReviewQuery) (*UserReviewQuery, error)
}

func newUserReviewPager(opts []UserReviewPaginateOption, reverse bool) (*userreviewPager, error) {
	pager := &userreviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserReviewOrder
	}
	return pager, nil
}

func (p *userreviewPager) applyFilter(query *UserReviewQuery) (*UserReviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userreviewPager) toCursor(ur *UserReview) Cursor {
	return p.order.Field.toCursor(ur)
}

func (p *userreviewPager) applyCursors(query *UserReviewQuery, after, before *Cursor) (*UserReviewQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserReviewOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userreviewPager) applyOrder(query *UserReviewQuery) *UserReviewQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserReviewOrder.Field {
		query = query.Order(DefaultUserReviewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userreviewPager) orderExpr(query *UserReviewQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserReviewOrder.Field {
			b.Comma().Ident(DefaultUserReviewOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserReview.
func (ur *UserReviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserReviewPaginateOption,
) (*UserReviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserReviewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ur, err = pager.applyFilter(ur); err != nil {
		return nil, err
	}
	conn := &UserReviewConnection{Edges: []*UserReviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ur.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ur, err = pager.applyCursors(ur, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ur.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ur = pager.applyOrder(ur)
	nodes, err := ur.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserReviewOrderField defines the ordering field of UserReview.
type UserReviewOrderField struct {
	// Value extracts the ordering value from the given UserReview.
	Value    func(*UserReview) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userreview.OrderOption
	toCursor func(*UserReview) Cursor
}

// UserReviewOrder defines the ordering of UserReview.
type UserReviewOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *UserReviewOrderField `json:"field"`
}

// DefaultUserReviewOrder is the default ordering of UserReview.
var DefaultUserReviewOrder = &UserReviewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserReviewOrderField{
		Value: func(ur *UserReview) (ent.Value, error) {
			return ur.ID, nil
		},
		column: userreview.FieldID,
		toTerm: userreview.ByID,
		toCursor: func(ur *UserReview) Cursor {
			return Cursor{ID: ur.ID}
		},
	},
}

// ToEdge converts UserReview into UserReviewEdge.
func (ur *UserReview) ToEdge(order *UserReviewOrder) *UserReviewEdge {
	if order == nil {
		order = DefaultUserReviewOrder
	}
	return &UserReviewEdge{
		Node:   ur,
		Cursor: order.Field.toCursor(ur),
	}
}
